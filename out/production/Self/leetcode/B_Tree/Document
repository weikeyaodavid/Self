

    Tree

    第 114 题：二叉树的前序遍历；
    第  94 题：二叉树的中序遍历；
    第 145 题：二叉树的后序遍历；
    第 102 题：二叉树的层序遍历；

    第 104 题：二叉树的最大深度（简单）：设计递归函数的返回值；
    第 111 题：二叉树的最小深度（简单）：设计递归函数的返回值；
    第 112 题：路径总和（简单）：设计递归函数的返回值；
    第 226 题：翻转二叉树（简单）：前中后序遍历、广度优先遍历均可，中序遍历有一个小小的坑；
    第 100 题：相同的树（简单）：设计递归函数的返回值；
    第 101 题：对称二叉树（简单）：设计递归函数的返回值；
    第 129 题：求根到叶子节点数字之和（中等）：设计递归函数的返回值。
    第 236 题：二叉树的最近公共祖先（中等）：使用后序遍历的典型问题。
    第 105 题：从前序与中序遍历序列构造二叉树（中等）；
    第 106 题：从中序与后序遍历序列构造二叉树（中等）；
    第 1008 题：前序遍历构造二叉搜索树（中等）；
    第 1028 题：从先序遍历还原二叉树（困难）。



    Trie 字典树 / 前缀树

    Trie 树是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

    工程中基本不会使用 Trie 。一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。
    另外，对于个别的超长字符 Trie 会进一步变深。这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作
    同时 Trie 的特殊结构，也会为分布式存储将会带来困难。因此在工程领域中 Trie 的应用面不广。

    至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。 ES 的实现则主要是依靠「倒排索引」

