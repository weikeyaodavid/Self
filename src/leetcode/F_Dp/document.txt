

    https://www.bilibili.com/video/BV1V14y1n7B6/?spm_id_from=pageDriver&vd_source=30813cdd3968362721bd4b3ad6e4ba94

    贪心：   每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
            如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
            贪心不能保证求得的最后解是最佳的，复杂度低
            子问题只有一个，只解一个


    动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解
            动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案结果正确性
            动态规划本质是穷举法，可以保证结果是最佳的，复杂度高
            子问题有很多重复，全部都要解



    先会 回溯法
    再学 记忆化搜索
    再学 二维DP
    再学 一维空间优化DP

    https://www.bilibili.com/video/BV1ho4y1W7QK/?spm_id_from=333.788.recommend_more_video.0&vd_source=30813cdd3968362721bd4b3ad6e4ba94









    动态规划分为重复子问题 和 最优子结构
    一般最值问题可以往动态规划去想

    这一类问题，问方案数，但不问具体方案的，可以考虑使用「动态规划」完成；
    「动态规划」处理字符串问题的思想是：从一个空串开始，一点一点得到更大规模的问题的解。

    子序列问题一般都是动态规划，复杂度 O(n2)
    另外，动态规划也是有套路的：单个数组或者字符串要用动态规划时，
    可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果；
    当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i][j]，
    其含义是在 A[0:i] 与 B[0:j]之间匹配得到的想要的结果。


    dp[i][j]
    最长子集和最长子序列的区别是   子集二维数组都记录自己i，j范围内的值  子序列都记录自己i,j范围内最大的值

    自顶向下
    int fib(int N) {
        if (N < 1) return 0;
        // 备忘录全初始化为 0
        vector<int> memo(N + 1, 0);
        // 进行带备忘录的递归
        return helper(memo, N);
    }
    int helper(vector<int>& memo, int n) {
        // base case
        if (n == 1 || n == 2) return 1;
        // 已经计算过
        if (memo[n] != 0) return memo[n];
        memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
        return memo[n];
    }


    自底向上
    int fib(int N) {
        if (N == 0) return 0;
        if (N == 1) return 1;
        vector<int> dp(N + 1, 0);
        // base case
        dp[1] = dp[2] = 1;
        for (int i = 3; i <= N; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[N];
    }


    背包问题框架
    0 - 1 背包问题  每种物品只可以取一次
    int dp[N+1][W+1]
    dp[0][..] = 0
    dp[..][0] = 0

    for i in [1..N]:
        for w in [1..W]:
            dp[i][w] = max(
                把物品 i 装进背包,  dp[i-1][w],
                不把物品 i 装进背包  dp[i-1][w - wt[i-1]] + val[i-1]
            )
    return dp[N][W]
    dp[i][w]的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]。

    比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。


==================================================================
    问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    动态规划：416.分割等和子集(opens new window)
    动态规划：1049.最后一块石头的重量 II(opens new window)

    问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：
    动态规划：494.目标和(opens new window)
    动态规划：518. 零钱兑换 II(opens new window)
    动态规划：377.组合总和Ⅳ(opens new window)
    动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)

    问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    动态规划：474.一和零(opens new window)

    问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
    动态规划：322.零钱兑换(opens new window)
    动态规划：279.完全平方数(opens new window)

==================================================================

    一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

    完全背包的一维dp数组实现，第二层for循环是从小到大遍历
    如果求组合数就是外层for循环遍历物品，内层for遍历背包。
    如果求排列数就是外层for遍历背包，内层for循环遍历物品。

==================================================================



