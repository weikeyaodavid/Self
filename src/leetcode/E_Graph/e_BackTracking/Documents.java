package leetcode.E_Graph.e_BackTracking;

public class Documents {

//    使用回溯法的明显标志
//            1. 排列、组合（子集、幂集、字符全排列）。 在传值时，对于排列问题，是要删掉单个用过的元素；组合问题，是删掉前面所有的元素。
//            2. 数组、字符串，给定一个特定的规则，尝试搜索迭代找到某个解。
//            3. 二维数组下的DFS搜索（八皇后、黄金矿工、数独）
//            4. 切割，子集，棋盘



    //回溯全排列还是不包含相同排列
    //全排列
    // for(int i = 0; i < nums.length; i++){
    //
    //不包含相同排列
    // for(int i = startIndex; i < nums.length; i++){



//    排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
//    组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。




    //经典回溯去重方法
    //在一个数组中包含相同元素的去重复组合方法
    // if(used[i] == 1 || (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == 0))continue;



//    代码框架      根据情况决定是否使用used[i]
//
//    result = []
//    def backtrack(路径, 选择列表):
//        if 满足结束条件:
//            result.add(路径)
//            return
//
//        for 选择 in 选择列表:
//            做选择
//            backtrack(路径, 选择列表)
//            撤销选择



//    题型一：排列、组合、子集相关问题
//    提示：这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， 为什么有的时候用 used 数组，有的时候设置搜索起点 begin 变量，理解状态变量设计的想法。
//
//            46. 全排列（中等）
//            47. 全排列 II（中等）：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；
//            39. 组合总和（中等）
//            40. 组合总和 II（中等）
//            77. 组合（中等）
//            78. 子集（中等）
//            90. 子集 II（中等）：剪枝技巧同 47 题、39 题、40 题；
//            60. 第 k 个排列（中等）：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；
//            93. 复原 IP 地址（中等）
//            37. 解数独（困难）：思路同「N 皇后问题」；

//
//    题型二：Flood Fill
//    提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。
//
//    下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。
//
//            733. 图像渲染（Flood Fill，中等）
//            200. 岛屿数量（中等）
//            130. 被围绕的区域（中等）
//            79. 单词搜索（中等）
//    说明：以上问题都不建议修改输入数据，设置 visited 数组是标准的做法。可能会遇到参数很多，是不是都可以写成成员变量的问题，面试中拿不准的记得问一下面试官
//
//
//
//    题型三：字符串中的回溯问题
//    提示：字符串的问题的特殊之处在于，字符串的拼接生成新对象，因此在这一类问题上没有显示「回溯」的过程，但是如果使用 StringBuilder 拼接字符串就另当别论。
//    在这里把它们单独作为一个题型，是希望朋友们能够注意到这个非常细节的地方。
//
//            17. 电话号码的字母组合（中等），题解；
//            784. 字母大小写全排列（中等）；
//            22. 括号生成（中等） ：这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。


}