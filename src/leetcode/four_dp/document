

    贪心：   每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
            如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
            贪心不能保证求得的最后解是最佳的，复杂度低
            子问题只有一个，只解一个


    动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解
            动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案结果正确性
            动态规划本质是穷举法，可以保证结果是最佳的，复杂度高
            子问题有很多重复，全部都要解



    动态规划分为重复子问题 和 最优子结构
    一般最值问题可以往动态规划去想

    这一类问题，问方案数，但不问具体方案的，可以考虑使用「动态规划」完成；
    「动态规划」处理字符串问题的思想是：从一个空串开始，一点一点得到更大规模的问题的解。


    自顶向下
    int fib(int N) {
        if (N < 1) return 0;
        // 备忘录全初始化为 0
        vector<int> memo(N + 1, 0);
        // 进行带备忘录的递归
        return helper(memo, N);
    }
    int helper(vector<int>& memo, int n) {
        // base case
        if (n == 1 || n == 2) return 1;
        // 已经计算过
        if (memo[n] != 0) return memo[n];
        memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
        return memo[n];
    }


    自底向上
    int fib(int N) {
        if (N == 0) return 0;
        if (N == 1) return 1;
        vector<int> dp(N + 1, 0);
        // base case
        dp[1] = dp[2] = 1;
        for (int i = 3; i <= N; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[N];
    }



