图论

储存图的方式

    1. 矩阵存图法
    一个很直观的想法就是用一个二维数组来存图，下标代表点，值代表连边的情况。这就是所谓的矩阵存图法，也被称作为邻接矩阵存图法。
    更具体地，我们一般使用 bool 数组来储存点与点之间的连边信息：
    如果 con[i][j] 的值为 true ，表示点 i 与点 j 之间连了一条从 i 指向 j 的边。
    如果 con[i][j] 的值为 false ，表示点 i 与点 j 之间没有连边。

    2. 邻接表存图法
    矩阵存图的最大的劣势，就是在面对稀疏图时，有很多空间没有储存有效信息（对于一个图，我们往往更加关注哪些点之间有连边，而不关注哪些点之间没有连边），
    被浪费掉了。一个优化的思路是：我们不再考虑储存每一个点对之间的连边信息，而只考虑那些有连边的点对。这样我们就能够保证所储存下来的信息都会是有效的。
    针对上述思路，对于一个有 n 的点的图，我们可以利用 n 个链表，第 i 个链表里存着所有从 i 直接连向的点。
    由于邻接表只储存了连接的边的信息，所以其空间复杂度为 Θ(m) （一般我们用 m 来表示图中边的数量），这相对于矩阵存图的 O(n2) 复杂度是一个很大优化。


并查集

    如果给你一些顶点，并且告诉你每个顶点的连接关系，你如何才能快速的找出两个顶点是否具有连通性呢？
    图给出了顶点与顶点之间的连接关系，那么，我们如何让计算机快速定位 (0, 3) , (1, 5), (7, 8) 是否相连呢？此时我们就需要机智的「并查集」数据结构了。
    「并查集」的主要作用是用来解决网络中的连通性。这里的「网络」可以是计算机的网络，也可以是人际关系的网络等等。
    例如，你可以通过「并查集」来判定两个人是否来自同一个祖先。


这种暂时先不了解
public class DFU_Size {

    int[] root;
    int[] size;

    public DFU_Size(int n) {
        root = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            root[i] = i;
        }
        Arrays.fill(size, 1);
    }

    public int find(int n) {
        if (root[n] != n){
            root[n] = find(root[n]);
        }
        return root[n];
    }

    public void union(int x, int y) {
        if (find(x) == find(y)) return;
        if (size[x] >= size[y]) {
            root[find(y)] = find(x);
            size[x] = size[x] + size[y];
        } else {
            root[find(x)] = find(y);
            size[y] = size[x] + size[y];
        }
    }
}
